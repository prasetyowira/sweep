// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/prasetyowira/sweep/internal/app/sweep/product/productadapter/ent/predicate"
	"github.com/prasetyowira/sweep/internal/app/sweep/product/productadapter/ent/product"
)

// ProductUpdate is the builder for updating Product entities.
type ProductUpdate struct {
	config

	sku             *string
	name            *string
	expirable       *bool
	is_deleted      *bool
	deleted_at      *time.Time
	cleardeleted_at bool
	created_at      *time.Time
	updated_at      *time.Time
	predicates      []predicate.Product
}

// Where adds a new predicate for the builder.
func (pu *ProductUpdate) Where(ps ...predicate.Product) *ProductUpdate {
	pu.predicates = append(pu.predicates, ps...)
	return pu
}

// SetSku sets the sku field.
func (pu *ProductUpdate) SetSku(s string) *ProductUpdate {
	pu.sku = &s
	return pu
}

// SetName sets the name field.
func (pu *ProductUpdate) SetName(s string) *ProductUpdate {
	pu.name = &s
	return pu
}

// SetExpirable sets the expirable field.
func (pu *ProductUpdate) SetExpirable(b bool) *ProductUpdate {
	pu.expirable = &b
	return pu
}

// SetNillableExpirable sets the expirable field if the given value is not nil.
func (pu *ProductUpdate) SetNillableExpirable(b *bool) *ProductUpdate {
	if b != nil {
		pu.SetExpirable(*b)
	}
	return pu
}

// SetIsDeleted sets the is_deleted field.
func (pu *ProductUpdate) SetIsDeleted(b bool) *ProductUpdate {
	pu.is_deleted = &b
	return pu
}

// SetNillableIsDeleted sets the is_deleted field if the given value is not nil.
func (pu *ProductUpdate) SetNillableIsDeleted(b *bool) *ProductUpdate {
	if b != nil {
		pu.SetIsDeleted(*b)
	}
	return pu
}

// SetDeletedAt sets the deleted_at field.
func (pu *ProductUpdate) SetDeletedAt(t time.Time) *ProductUpdate {
	pu.deleted_at = &t
	return pu
}

// SetNillableDeletedAt sets the deleted_at field if the given value is not nil.
func (pu *ProductUpdate) SetNillableDeletedAt(t *time.Time) *ProductUpdate {
	if t != nil {
		pu.SetDeletedAt(*t)
	}
	return pu
}

// ClearDeletedAt clears the value of deleted_at.
func (pu *ProductUpdate) ClearDeletedAt() *ProductUpdate {
	pu.deleted_at = nil
	pu.cleardeleted_at = true
	return pu
}

// SetCreatedAt sets the created_at field.
func (pu *ProductUpdate) SetCreatedAt(t time.Time) *ProductUpdate {
	pu.created_at = &t
	return pu
}

// SetNillableCreatedAt sets the created_at field if the given value is not nil.
func (pu *ProductUpdate) SetNillableCreatedAt(t *time.Time) *ProductUpdate {
	if t != nil {
		pu.SetCreatedAt(*t)
	}
	return pu
}

// SetUpdatedAt sets the updated_at field.
func (pu *ProductUpdate) SetUpdatedAt(t time.Time) *ProductUpdate {
	pu.updated_at = &t
	return pu
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (pu *ProductUpdate) Save(ctx context.Context) (int, error) {
	if pu.sku != nil {
		if err := product.SkuValidator(*pu.sku); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"sku\": %v", err)
		}
	}
	if pu.name != nil {
		if err := product.NameValidator(*pu.name); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"name\": %v", err)
		}
	}
	if pu.updated_at == nil {
		v := product.UpdateDefaultUpdatedAt()
		pu.updated_at = &v
	}
	return pu.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (pu *ProductUpdate) SaveX(ctx context.Context) int {
	affected, err := pu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (pu *ProductUpdate) Exec(ctx context.Context) error {
	_, err := pu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (pu *ProductUpdate) ExecX(ctx context.Context) {
	if err := pu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (pu *ProductUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   product.Table,
			Columns: product.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: product.FieldID,
			},
		},
	}
	if ps := pu.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value := pu.sku; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: product.FieldSku,
		})
	}
	if value := pu.name; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: product.FieldName,
		})
	}
	if value := pu.expirable; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: product.FieldExpirable,
		})
	}
	if value := pu.is_deleted; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: product.FieldIsDeleted,
		})
	}
	if value := pu.deleted_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: product.FieldDeletedAt,
		})
	}
	if pu.cleardeleted_at {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: product.FieldDeletedAt,
		})
	}
	if value := pu.created_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: product.FieldCreatedAt,
		})
	}
	if value := pu.updated_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: product.FieldUpdatedAt,
		})
	}
	if n, err = sqlgraph.UpdateNodes(ctx, pu.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// ProductUpdateOne is the builder for updating a single Product entity.
type ProductUpdateOne struct {
	config
	id int

	sku             *string
	name            *string
	expirable       *bool
	is_deleted      *bool
	deleted_at      *time.Time
	cleardeleted_at bool
	created_at      *time.Time
	updated_at      *time.Time
}

// SetSku sets the sku field.
func (puo *ProductUpdateOne) SetSku(s string) *ProductUpdateOne {
	puo.sku = &s
	return puo
}

// SetName sets the name field.
func (puo *ProductUpdateOne) SetName(s string) *ProductUpdateOne {
	puo.name = &s
	return puo
}

// SetExpirable sets the expirable field.
func (puo *ProductUpdateOne) SetExpirable(b bool) *ProductUpdateOne {
	puo.expirable = &b
	return puo
}

// SetNillableExpirable sets the expirable field if the given value is not nil.
func (puo *ProductUpdateOne) SetNillableExpirable(b *bool) *ProductUpdateOne {
	if b != nil {
		puo.SetExpirable(*b)
	}
	return puo
}

// SetIsDeleted sets the is_deleted field.
func (puo *ProductUpdateOne) SetIsDeleted(b bool) *ProductUpdateOne {
	puo.is_deleted = &b
	return puo
}

// SetNillableIsDeleted sets the is_deleted field if the given value is not nil.
func (puo *ProductUpdateOne) SetNillableIsDeleted(b *bool) *ProductUpdateOne {
	if b != nil {
		puo.SetIsDeleted(*b)
	}
	return puo
}

// SetDeletedAt sets the deleted_at field.
func (puo *ProductUpdateOne) SetDeletedAt(t time.Time) *ProductUpdateOne {
	puo.deleted_at = &t
	return puo
}

// SetNillableDeletedAt sets the deleted_at field if the given value is not nil.
func (puo *ProductUpdateOne) SetNillableDeletedAt(t *time.Time) *ProductUpdateOne {
	if t != nil {
		puo.SetDeletedAt(*t)
	}
	return puo
}

// ClearDeletedAt clears the value of deleted_at.
func (puo *ProductUpdateOne) ClearDeletedAt() *ProductUpdateOne {
	puo.deleted_at = nil
	puo.cleardeleted_at = true
	return puo
}

// SetCreatedAt sets the created_at field.
func (puo *ProductUpdateOne) SetCreatedAt(t time.Time) *ProductUpdateOne {
	puo.created_at = &t
	return puo
}

// SetNillableCreatedAt sets the created_at field if the given value is not nil.
func (puo *ProductUpdateOne) SetNillableCreatedAt(t *time.Time) *ProductUpdateOne {
	if t != nil {
		puo.SetCreatedAt(*t)
	}
	return puo
}

// SetUpdatedAt sets the updated_at field.
func (puo *ProductUpdateOne) SetUpdatedAt(t time.Time) *ProductUpdateOne {
	puo.updated_at = &t
	return puo
}

// Save executes the query and returns the updated entity.
func (puo *ProductUpdateOne) Save(ctx context.Context) (*Product, error) {
	if puo.sku != nil {
		if err := product.SkuValidator(*puo.sku); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"sku\": %v", err)
		}
	}
	if puo.name != nil {
		if err := product.NameValidator(*puo.name); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"name\": %v", err)
		}
	}
	if puo.updated_at == nil {
		v := product.UpdateDefaultUpdatedAt()
		puo.updated_at = &v
	}
	return puo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (puo *ProductUpdateOne) SaveX(ctx context.Context) *Product {
	pr, err := puo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return pr
}

// Exec executes the query on the entity.
func (puo *ProductUpdateOne) Exec(ctx context.Context) error {
	_, err := puo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (puo *ProductUpdateOne) ExecX(ctx context.Context) {
	if err := puo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (puo *ProductUpdateOne) sqlSave(ctx context.Context) (pr *Product, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   product.Table,
			Columns: product.Columns,
			ID: &sqlgraph.FieldSpec{
				Value:  puo.id,
				Type:   field.TypeInt,
				Column: product.FieldID,
			},
		},
	}
	if value := puo.sku; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: product.FieldSku,
		})
	}
	if value := puo.name; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: product.FieldName,
		})
	}
	if value := puo.expirable; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: product.FieldExpirable,
		})
	}
	if value := puo.is_deleted; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: product.FieldIsDeleted,
		})
	}
	if value := puo.deleted_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: product.FieldDeletedAt,
		})
	}
	if puo.cleardeleted_at {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: product.FieldDeletedAt,
		})
	}
	if value := puo.created_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: product.FieldCreatedAt,
		})
	}
	if value := puo.updated_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: product.FieldUpdatedAt,
		})
	}
	pr = &Product{config: puo.config}
	_spec.Assign = pr.assignValues
	_spec.ScanValues = pr.scanValues()
	if err = sqlgraph.UpdateNode(ctx, puo.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return pr, nil
}
